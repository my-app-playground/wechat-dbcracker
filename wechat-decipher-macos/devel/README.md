# Note to Hackers

WeChat makes extensive use of [Protocol Buffers](https://developers.google.com/protocol-buffers), but the code generated by `protoc` has been heavily modified to fit into mobile devices, hindering our reverse engineering. Fortunately, the article [iOS微信安装包瘦身](https://cloud.tencent.com/developer/article/1030792) provides a decent overview of protobuf's integration into WeChat's iOS client. Based on the information, we created a helper function `show_fields_recursive` to dissect instances of subclasses of `WXPBGeneratedMessage`. The function resides in `init.js` and should work for both iOS and macOS.

+ For iOS, run `frida-trace -U -n WeChat -m "-[ProtobufCGIWrap setM_pbRequest:]" -m "-[ProtobufCGIWrap setM_pbResponse:]" --init-session=init.js` to dump the client's communication with the server. You need to [install Frida on your iOS device](https://frida.re/docs/ios/) first.
+ For macOS, use `frida-trace -n WeChat -m "-[MMCGIWrap setM_requestPb:]" -m "-[MMCGIWrap setM_responsePb:]" --init-session init.js`. Without the `-U` switch, Frida attaches to the WeChat process on macOS instead.

In addition, apart from `xlogger.d`, you can also use Frida to inspect the log messages. Simply run `frida-trace -U -n WeChat -i "__xlogger_Write_impl" -i "__xlogger_Level_impl"` for iOS, or `frida-trace -n WeChat -i "__xlogger_Write_impl" -i "__xlogger_Level_impl"` for macOS.

## Overview of the Backup Process

In this part, we briefly describe the process of a backup from WeChat's iOS client to its macOS client. Only key steps are covered.

1. Both clients get a 256-bit "encryptkey" from the remote server.
    + This is *NOT* the same key as used by `macos/dbcracker.d`.
    + The ASCII representation of the key consists of 32 hexadecimal digits, so there are merely 128 bits of entropy. However, we consider it a 256-bit key anyway since it still takes 256 bits of space to store.
2. On the iOS device, the relevant chat history is fetched from the [wcdb](https://github.com/Tencent/wcdb) subsystem into `CMessageWrap` objects in `-[WXGBackupMMDB getMsgUseBatchQuery:fromRowID:fromCreateTime:endAtTime:timeAsend:]`.
3. The `CMessageWrap` objects are somehow transformed into several `BakChatMsgList` objects. There appears to be one `BakChatMsgList` per contact.
4. The `BakChatMsgList` objects are serialized into protobuf (with `-[WXPBGeneratedMessage serializedData]`), encrypted in AES-128-ECB (with `-[CAESCrypt initECBEncryptWithKey:]` and `-[CAESCrypt encryptECBWithData:Final:]`).
    + The encrypt key is the first 128 bits (i.e. first half) of "encryptkey".
    + `BakChatMsgList` is a subclass of `WXPBGeneratedMessage`, so its instances can be understood by `show_fields_recursive`, based on whose output we reconstructed `pcbakchat/proto/BakChatMsgList.proto`.
5. Media data are also encrypted in AES-128-ECB (in `-[WXGBackupDataMgr purgeMediaArray:]`).
6. The encrypted protobufs are then packed with metadata like `dataID` (presumably an identifier of the chat history) into a "datapush", which is another layer of protobuf (in `-[WXGBackupDataMgr getBackupDataPushFromBakChatMsgList:withDataID:]`).
7. The datapushes are encrypted in RC4 and sent to the macOS client over Wi-Fi.
    + The encrypt key is the 256-bit "encryptkey" in all its entirety.
8. On the macOS client, datapushes are decrypted in RC4 (with `CCCryptor`) and deserialized.
    + The macOS client appears to re-encrypt the datapushes after decryption, presumably with some modification to the payload. TODO: investigate this behavior.
9. Finally, `dataID` is extracted and used to dispatch the encrypted "inner" protobuf to one of `BAK_X_TEXT`.

**TL;DR:** the chat history is packed, encrypted in AES-128-ECB, packed with some metadata, encrypted with RC4, sent over Wi-Fi, decrypted (RC4), unpacked, and stored to the disk.